#!/usr/bin/env ruby

# Bundler setup
require 'rubygems'
require 'bundler/setup'
Bundler.require(:default)

require 'colorize'
require 'json'

# Mandatory expenses sometimes
RENT = 1900

# Don't plan for spending that leaves you with less than this amount
TARGET = 1500

debts = [
	{ creditor: "Chase::United",
	  apr: 0.25,
    balance: nil,
    minimum: nil,
	  payment: nil },
  { creditor:"Chase::Amazon",
    apr: 0.229,
    balance: nil,
    minimum: nil,
    payment: nil },
	{ creditor: "SFFCU",
	  apr: 0.049,
    balance: nil,
    minimum: nil,
	  payment: nil },
	{ creditor: "Apple",
	  apr: 0.0,
    balance: nil,
    minimum: 324.83,
	  payment: nil },
]

#
# Get Available Cash
#
print "How much cash do you have on hand? ($4100): $"
cash = gets.chomp

CASH_ON_HAND = if cash.empty? || cash.nil?
                 4100.0
               else
                 cash.to_f
               end

pool = CASH_ON_HAND - TARGET

#
# Get Balances
#
total_debt = 0.0

print "\nTry to load from .cashier file? (Y/n): "
load_dotfile = gets.chomp
load_dotfile ||= ''
if load_dotfile.downcase == 'y' or load_dotfile.downcase == 'yes' or load_dotfile.empty?
  begin
    file = File.read('.cashier')
    cashier_cache = JSON.parse(file)
    debts.each do |debt|
      cashier_cache.each do |c|
        if c['creditor'] == debt[:creditor]
          debt[:balance] = c['balance']
        else
          next
        end
      end
    end

    puts "Found the following balances in the .cashier file:".green
    debts.each { |d| puts "#{d[:creditor]}: #{d[:balance].round(2)}".bold }

    print "\nIs this correct? (Y/n): "
    correct_balances = gets.chomp
  rescue Errno::ENOENT => e
    puts "No .cashier file found. Defaulting to manual input..."
    correct_balances = 'n'
  end
end

correct_balances ||= ''
if correct_balances.empty? or correct_balances.downcase == 'n'
  debts.each do |debt|
    print "Enter #{debt[:creditor]} balance: $"
    debt[:balance] = gets.chomp.to_f
  end
end

debts.each do |debt|
  if debt[:balance].nil?
    debts[:balance] = 0.0
  end
    total_debt += debt[:balance]
end

puts "Total Debt: #{total_debt.round(2)}".red.bold

#
# Sort debts by APR
#
debts = debts.sort_by { |k| k[:apr] }
debts.reverse!

#
# Figure out if this paycheck has to cover rent as well as other 1st-of-the-month-type-things
#

# Manual Check
print "\nUse automatic rent calculator? (Y/n): "
auto_rent = gets.chomp

if auto_rent.downcase == 'n' or auto_rent.downcase == 'no'
  print "\nSubtract rent payment? (y/N): "
  subtract_rent = gets.chomp
  unless subtract_rent.downcase == 'n' or subtract_rent.downcase == 'no' or subtract_rent.empty?
    pool -= RENT
  end
else
  today = Time.now
  first_of_next_month = Time.new(today.year, (today.month + 1), 1)
  if (first_of_next_month - today) <= 1209600
	  puts "Your next paycheck needs rent money! Pay the rent. Removing rent money from available pool...".red
	  pool -= RENT
  end
end

puts "AVAILABLE CASH: $#{pool.round(2)}".green
puts "\n\n"

#
# Check minimum payments
#
debts.each do |debt|
  cmd = "Enter any minimum payment due to #{debt[:creditor]} & not yet paid this month"
  if debt[:minimum].nil?
    cmd = cmd + ": $"
  else
    cmd = cmd + " (#{debt[:minimum]}; RETURN to accept): $"
  end

  print cmd
  minimum = gets.chomp

  if minimum.nil? || minimum.empty?
    if debt[:minimum].nil?
      debt[:minimum] = 0.0
    else
      pool -= debt[:minimum]
    end
  elsif minimum.to_f.zero?
    debt[:minimum] = 0.0
  else
    debt[:minimum] = minimum.to_f
    pool -= debt[:minimum]
  end

  debt[:payment] = debt[:minimum]
  print "\n"
end

if pool > 0.0
# Allocate remainder to accounts in order of descending APR
  debts.each do |debt|
    break if pool <= 0

    if (debt[:balance] - debt[:payment]) <= pool
      puts "LOG: available cash ($#{pool}) is greater than the balance of #{debt[:creditor]} debt (less any planned minimum payments); recommend paying #{debt[:creditor]} the full balance of $#{debt[:balance].round(2)}."
      pool -= (debt[:balance] - debt[:payment])
      debt[:payment] = debt[:balance]
    else
      debt[:payment] += pool
      pool = 0.0
    end
  end
else
# Advise to make only minimum payments if there's not enough cash to do more
  puts "Planned debt reduction costs are too high to go beyond minimum payments at this time; make those and move on."
end

# List payments
debts.each do |debt|
  puts "PAY #{debt[:creditor]}: #{debt[:payment].round(2)}".blue.bold
  total_debt -= debt[:payment]
  debt[:balance] -= debt[:payment]
end

puts "Projected debt after today's payments: $#{total_debt.to_i}".green.bold

# Write balances to file
puts "All done! Writing current state of finances to .cashier.".bold
File.write('.cashier', JSON.dump(debts))
